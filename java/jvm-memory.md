# JVM 메모리 구조
## JVM

자바 가상 머신으로 자바 바이트 코드를 실행할 수 있는 주체

CPU나 운영체제의 종류와 무관하게 실행이 가능. 운영체제 위에서 동작하는 프로세스로 자바 코드를 컴파일해서 얻은 바이트 코드를 해당 운영체제가 이해할수 있는 기계어로 바꿔 실행해주는 역할.

JMV의 구성은  4가지로 나뉜다.

- Class Loader
- Execution Engine
- Garbage Collector
- RuntimeData Area

### Class Loader

.java → 컴파일 → .class 파일 (바이트코드) 생성된다.

이렇게 생성된 클래스파일을 엮어서 JVM이 운영체제로부터 할당받은 메모리 영역인 Runtime DataArea로 적재하는 역할을 Class Loader가 한다.

### Execution Engine

클래스로더에의해 메모리에 적재된 클래스들을 기계어로 변경해 명령어 단위를 실행하는 역할을 한다.

명령어를 하나씩 실행하는 인터프리터 방식이 있고, JIT(Just In Time) 컴파일러를 이용하는 방식이 있다.

JIT 컴파일러는 적절한 시간에 전체 바이트 코드를 네이티브 코드로 변경해서 Execution Engine이 네이티브로 컴파일된 코드를 실행하는것으로 성능을 높인다.

### Garbage Collector

Heap 메모리 영역에 생성된 객체들 중에 참조되지 않은 객체들을 탐색후 제거하는 역할을 한다.

GC가 수행하는 시간은 정확하게 알수 없고, GC가 수행되는 시간은 STW가 발생한다.

### Runtime Data Area

JVM의 메모리 영역으로 자바 어플리케이션을 실행할때 사용되는 데이터들을 적재하는 영역이다

이는 5가지 영역으로 나뉜다.

- **Method Area**
    - 클래스 멤버 변수 이름, 데이터 타입, 접근 제어자 정보같은 **필드 정보**와, 메서드 이름, 리턴타입, 파라미터, 접근제어자 정보의 **메서드 정보**, **타입 정보**, **상수풀** (문자상수, 타입, 필드, 객체 참조), **static 변수**, **final class 변수**등이 생성되는 영역
    - Runtime Constant Pool
        - 클래스 파일의 constant_pool 테이블에 해당하는 영역
        - 클래스와 인터페이스 상수, 메서드와 필드에 대한 모든 레버런스를 저장한다
        - JVM은 런타임 상수풀을 통해 해당 메서드나 필드의 실제 메모리상 주소를 찾아 참조한다.
- **Heap Area**
    - JVM이 관리하는 프로그램 상에서 데이터를 저장하기 위해 런타임 시 동적으로 할당하여 사용하는 영역이다.
    - New 키워드로 생성된 객체와 배열이 생성되는 영역이다. 메서드 영역에 로드된 클래스만 생성이 가능하고, GC가 참조되지 않은 메모리를 확인하고 제거한다.
    - 힙 영역으로는 GC의 주 대상으로 더 살펴 보아야 한다. (메서드 영역, 스택영역도 GC의 대상이다)
        - **Eden**
        - **Survivor 1**
        - **Survivor 2**
        - **Old**
          - 
        - **Permanent**  (JDK 7 까지 존재 이후 **meta space** 영역으로 변경) ****
            - 클래스 로더에 의해 로드되는 클래스, 메서드 등에 대한 메타 정보가 저장되는 영역으로 JVM에 의해 사용된다. 리플렉션을 사용하여 동적으로 클래스가 로딩되는 경우에 사용된다. 런타임시 사이즈를 조절할 수 없어 OOM이 발생하는 메모리 영역
    - GC
        - **Minor GC : new  영역 (eden, s1, s2) 에서 일어나는 GC**
            - 최초에 객체가 생성될때 eden으로 생성.eden영역에 객체가 가득차면 첫번째 GC가 일어난다.
            - eden 영역의 메모리를 그대로 복소한다. 그리고 s1 영역을 제외한 다른 영역(eden)의 객체를 제거한다.
            - eden 영역, s1 영역도 가득 차면 eden 영역에 생성된 객체와 s1 영역에 생성된 객체 중에 참조되고 있는 객체가 있는지 검사한다.
            - 참조되지 않는 객체는 내버려두고 참조되고 있는 객체만 s2로 복사한다. .s2영역을 제외한 다른 영역의 객체들은 제거한다.
            - 위 과정중에 일정 횟수 이상 참조되고 있는 객체는 s2 → old 영역으로 이동한다.
            - 위 과정을 반복하고 s2 영역이 꽉차리 전에 계속 old로 이동한다.
        - **Major GC : Old 영역 (old, permanent)에서 일어나는 GC**
            - Old 영역에 있는 모든 객체들을 검사하며 참조되고 있는지 확인
            - 참조되지 않는 객체들을 모아 한번에 제거
            - minor GC 보다 오래걸리고 모든 스레드 중지.

- **Stack Area**
    - 지역변수, 파라미터, 리턴 값, 연산에 사용되는 임시 값등이 생성되는 영역이다.
    - int a  = 10; 정수값이 할당될 수 있는 메모리공간 a를 잡아두고, 그 메모리 영역에 값이 10이 들어간다. 즉 스택에 메모리 이름이 a라고 붙여주고 값이 10인 공간을 만든다
    - 클래스 Person p = new Person(); Person p 는 스택에 생성, new로 생성된 Person 클래스의 인스턴스는 힙에 생성되어 스택 영역에 생성된 p의 값으로 힙 영역의 주소값을 가지고 있는다. 즉 스택 영역에 생성된 p가 힙 영역의 생성된 객체를 참조하고 있는것이다. 메서드를 호출할때마다 개별적으로 스택이 생성된다.
- **PC register**
    - 스레드가 생성될때마다 생성되는 영역으로 program counter 현재 스레드가 실행되는 부분의 주소와 명령을 저장하고 있는 영역이다.
    - 이를 이용해 스레드를 돌아가면서 수행할 수 있게 한다.
- **Native Method Stack**
    - 자바 외 언어로 작성된 네이티브 코드를 위한 메모리 영역이다

- 스레드가 생성되었을때 기준으로 메소드영역과 힙 영역을 모든 스레드가 공유하고, 스택영역,  PC레지스터, 네이티브 메서드 스택은 공유되지 않는다.