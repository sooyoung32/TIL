# 6장 디버깅과 테스트
디버깅과 테스트가 어려운이유

- 리액이브 프로그래밍에서 생산자가 소비자에게 통지하는 데이터는 외부에서 접근 불가
- 비동기 처리시에는 여러 처리가 동시에 실행되므로 실행할 때마다 결과가 달라짐.

아래의 메서드 제공

### do로 시작하는 메서드

- 통지시점에 미리 지정한 처리를 수행하는 메서드
- 통지할때나 통지 이후 부가작용이 발생하는 메서드 제공 (doOn, doAfter)
- 기본적으로 통지 후 부가작용은 소비자에서 처리하는것이 이상적 -
- 메서드 종류
    - doOnNext :통지시 지정한 작업 실행
    - doOnComplete : 통지 완료시 지정한 처리작업 실행
    - doOnError : 에러 발생시 실행
    - ...

### **blocking시작하는 메서드**

- Flowable, Observable 호출자의 스레드가 아닌 다른 스레드에서 처리를 하더라도 호출자의 스레드에서 결과를 받게하는 메서드
- 비동기 처리 결과를 현재 실행 중인 스레드에서 받을 수 있는 메서드
- 테스트 실행하는 스레드에서 비동기 통지의 결과값을 받을 수 있어 결과값과 기대값을 비교하면서 테스트 가능
- 메서드
    - blockingFirst : 호출한 스레드의 첫번째 통지 데이터를 받게하는 메서드
    - blockingLast: 호출한 스레드의 마지막 통지 데이터를 받게하는 메서드
    - blockingIterable: 호출한 스레드에서 통지하는 모든 데이터를 받는 Iterable을 얻게 하는메서드.
    - blockingSubscribe : 호출한 스레드에서 소비자의 통지 데이터 처리를 실행할 수 있게 하는 메서드

### **TestSubscriber, TestObserver**

- 테스트 할때 생성하는 Subscriber, Observer클래스로 assert 메서드와 같은 테스트 목적으로 사용할 수 있는 메서드 제공 (assert, await)

### **TestScheduler**

- 테스트할 때 실제로 실행시간 경과를 기다리지 않고 내부적으로 계산해 예상되는 통지 데이터 결과를 빠르게 받을 수 있는 테스트 용도의 스케줄러
- 지정한 시간에 진행할 처리를 실제 시간을 쓰지 않고 테스트 가능한 스케줄러
- TestScheduler는 interval, timer 등 시간관려된 데이터만 다룰때 사용할 수 있고 실제로 처리 할때 걸리는 시간이 단축되는것음 아님.
- 테스트결과는 지정한 시간을 기반으로 계산함.