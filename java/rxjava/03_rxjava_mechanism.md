# RxJava 매커니즘
## RxJava 와 디자인 패턴

### 옵저버 패턴

- RxJava는 옵저버 패턴을 확장한 구조.
- 옵저버 패턴은 관찰대상 객체의 상태에 변화가 발생하면 객체를 관찰하는 객체가 변화에 따른 처리작업을 하는 디자인 패턴
- SubJect
    - 관찰 대상을 나타내는 클래스로 이 클래스에 Observer를 추가하거나 삭제 할 수 있으며
    - 상태 변화가 발생했을떄 통지 처리 기능이 있다
- Observer
    - 변화가 발생했을때 이를 처리하는 메서드가 있는 인터페이스
- ConcreteSubject
    - Subject를 상속한 클래스
    - 슬제 변화가 이 클래스에서 일어나며 변화가 발생했을 떄 Subject의 통지 처리 메서드를 호출해 등록된 Observer에 통지
- ConcreteObserver
    - Observer의 구현클래스로 통지가 발생했을때 처리할 내용 구현
- 옵저버 패턴의 가장 중요한 특징은 관찰 대상인 Subject에 상태 변화가 발생했을때 Subject 스스로 자신에게 변화가 발생했다고  Observer에게 통지한다는 것과 관찰 대상인 subject와 관찰하는 observer가 분리 됐다는 점
- RxJava에서 생산자와 소비자 관계에는 당연히 옵저퍼 패턴이 적용!
- 옵저버 패턴의 Subject를 생산자로, 상대 변화에 따른 처리를 담당하는 Observer를 소비자로

### 이터레이터 패턴

- 데이터 집합체에서 순서대로 테이터를 꺼내기 위한 패턴
- 이터레이터를 생성 → 이터레이터로 데이터를 순서대로 얻을 수 있게 하는데, 이때 데이터 집합체가 어떤형태로 데이터를 가지고 있는지는 iterator를 사용하는 측에서는 알 필요가 없음.
- 단순히 hasNext(), next() 메서드로 데이터를 얻고 이 데이터를 사용해 처리 작업을 반복!
- Aggregate : 데이터를 담고 있는 집합체를 나타내는 인터페이스
- Iterator : 데이터를 순서대로 받을 수 있게 하는 인터페이스
- ConcreteAggregate : 실제 데이터를 넣어 두는 데이터 집합체를 구현한 클래스
- ConcreteIterator : 실제 데이터를 받을 수 있게 iterator를 구현한 클래스
- RxJava에서는 생산자 자체가 데이터 집합체이므로 데이터를 순서대로 공급하는 역할을 하기도 함
- RxJava는 이터레이터 패턴처럼 소비자가 데이터를 가져가는 형태 (pull)이 아니라, 소비자에게 데이터를 통지하는 형태 (push)

## 비동기 처리

### RxJava에서 비동기 처리

- RxJava에서는 비동기 처리를 하도록 설정하지 않는 한 , 생산자와 소비자가 동일한 스레드에서 실행.
- 같은 스레드에서 수행할 경우, 데이터를 통지하는 측은 데이터를 받아 처리하는 측의 속도에 영향을 줌.
- RxJava에서 비동기 처리할 때는 생산차가 처리해야하는 스레드와 소비자의 스레드를 모두 관리해야함.
    - 생산자 : subscribeOn
    - 소비자 : observeOn

### 스케줄러

- 스케줄러는 RxJava에서 제공하는 스레드를 관리하는 클래스
- computataion : 연산처리할 때 사용하는 스케줄러, 논리 프로세서 수와 같은 수 만큼 스래드를 캐시. I/O 작업에서 사용 불가
- io: I/O 작업시 사용하는 스레줄러로 스레드 풀에서 스레드를 가져오며, 필요에 따라 새로운 스레드
- single : single 스레드
- newThread: 매번 새로운 스레드
- from : 저장한 Executor 가 생성한 스레드
- trampoline : 현재 스레드 큐에 처리작업을 넣는 스케줄러

**SubcribeOn**

- 생산자의 처리 작업을 어떤 스케줄러에서 실행할지 설정하는 메서드

**ObserveOn**

- 데이터를 받는 측의 처리 작업을 어떤 스케줄러에서 실행할지 설정하는 메서드
    - buffersize : 버퍼에 담긴 통지 대기 데이터에서 인자 크기 만큼 소비자에게 통지할 데이터 사이즈. default : 128

### 에러처리

- 명시적으로 에러를 구현하지 않아도 처리중에 에러가 발생하면 에러를 던지고 중단하는 거이 아니라, 기본적으로 소비자에게 발생한 에러를 통지하게 이뤄짐.
- 재시도를 통한 에러처리는 재실행될때 Flowable의 통지 처리를 처음부터 다시시작

### 배압

- 배압이란 데이터 통지량을 제어하는 기능
- 배압은 Flowable과 데이터를 받는 측이 서로 다른 스레드에서 처리하는데 Flowable이 데이터를 통지하는 속도가 데이터를  받는 측의 처리 속도보다 빠를때 필요함.
- 데이터를 통지하는 속도가 받는 측보다 빠를때 배압 기능이 없다면, 시간이 지랄 수록 처리를 기다리는 데이터가 쌓이게돼, 최신 결과를 신속하게 받을 수 없고  결국 메모리가 부족해져 시스템 다움..
- Flowable 이 통지를 기대리는 데이터를 어떻게 다룰 것인지가 BackpressureStrategy
    - Buffer : 데이터를 통지할 수 있게 될 때까지 모든 데이터를 버퍼에 쌓는다
    - Drop : 데이터를 통지할 수 있게 될 때까지 새로 생성한 모든 데이터를 파기한다
    - Latest: 생성한 최신 데이터만 버퍼에 담고, 새로 데이터가 생성되면 버퍼에 담긴 데이터를 최신 데이터로 교체한다
    - Error : 통지를 기다리는 데이터가 버퍼크기를 넘기면 missingBackpressureExcetpion 에러 통지
    - None :  특정 처리 작업을 실행하지 않는다.