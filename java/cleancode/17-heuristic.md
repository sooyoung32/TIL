# 17장 냄새와 휴리스틱

### 주석

- 부적절한 정보
    - 다른 시스템에 저장될 정보 (ex. VCS)는 주석으로 적절하지 못한다.
- 쓸모없는 주석
    - ex. 오래된주석, 잘못된 주석
- 중복된 주석
    - 코드만으로 충분한데 구구절절 설명하는 주석
    - 서명만 있는 주석
- 성의 없는 주석
    - 주석을 달거라면 죄대한 멋지게!
    - 간결, 명로하게
- 주석 처리된 코드
    - 주석으로 처리된 코드는 흉물 그 자체 🤢
    - 주석 코드는 즉각 지워라!

### 환경

- 여러단계로 빌드
    - 빌드는 한 단계로 끝나야한다.
- 여런단계로 테스트
    - 모든 단위 테스트는 한 명령으로 돌려야한다.
    - 빠르고 명백해야한다.

### 함수

- 너무 많은 인수
    - 함수에서 인수 개수는 작을 수록 좋다.
    - 없는거 > 인자 1개 > 인자 2개 > 인자 3개
    - 그 이상은 가치가 의심스러움으로 최대한 피한다.
- 출력 인수
    - 함수에서 뭔가 상태를 변경해야한다면 함수가 속한 객체의 상태를 변경한다.
- 플래그 인수
    - boolean은 여러 기능을 수행한다는 명백한 증거다
    - 플래그 인수는 피해야 마땅하다.
- 죽은 함수
    - 아무도 호출하지 않는 함수는 삭제한다.

### 일반

- 한 소스 파일에 여러 언어를 사용한다
    - 자바 파일에 XML, HTML, YAML, 영어가 포함한다거나.
    - 소스파일 하나에 언어 하나만 사용하는 방식이 좋다
- 당연한 동작을 구현하지 않는다
    - 함수나 클래스는 다른 프로그래머가 당연하게 여길 만한 동작과 기능을 제공해야한다.
- 경계를 올바로 처리하지 않는다
    - 코드는 올바로 동작해야한다..
    - 부리런함을 대신할 지름길은 없다.
    - 모든 경계 조건을 찾고 모든 경계 조건을 테스트하고 TC를 작성하자.
- 안전절차 무시
    - 실패하는 테스트 케이스를 일단 제껴두고 나중으로 미루는 태도는 신용카드가 공짜 돈이라는 생각만큼 위험하다.
- 중복
    - **가장 중요한 규칙**
    - DRY Dont Repeat Yourslef, Once and only once
    - 코드에서 중복을 발견할 때마다 추상화할 기회로 간주하라. 중복된 코드를 하위 루틴이나 다른 클래스로 분리하라
    - 유형 1 - 같은 코드가 여러차례 나오는 중복
    - 유형 2 - 어러모듈에서 일련의 switch/case, if/else 문으로 똑같은 조건을 거듭 확인하는 중복. 이런 중복은 다형성으로 대체해야한다.
    - 유형 3- 알고리즘이 유사하나 코드가 서로 다른 중복 - 중복은 중복이므로 템플릿메서드 패턴이나, 전략패턴으로 중복을 제거한다.
- 추상화 수준이 올바르지 못하다
    - 추상화는 저차원 상세 개념에서 고차원 일반개념을 분리한다.
    - 모든 저차원 개념은 파생클래스에 넣고, 고차원 개념은 기초 클래스에 넣는다
- 기초 클래스가 파생클래스에 의존한다
    - 기초와 파생으로 나누는 이유는 고차원 기초 클래스 개념을 저차원 파생 클래스 개념으로 분리해 독립성을 보장하기 위해
    - 기초 클래스가 파생클래스를 사용한다면 문제가 있다는 말이다.
    - 일반적으로 기초 클래스는 파생 클래스를 아예 몰라야 한다.
- 과도한 정보
    - 잘 정의된 모듈은 인터페이스가 아주 작다.
    - 잘 정의된 인터페이스는 많은 함수를 제공하지 않는다. 그래서 결합도가 낮다.
    - 클래스가 제공하는 메서드는 작을 수록 좋다
    - 자료를 숨기고, 유틸리티 함수를 숨겨라. 상수와 임시 변수를 숨겨라.
    - 메서드나 인스턴스 변수가 넘치는 클래스는 피하라.
    - 인터페이스를 매우 작게 그리고 매우 깐깐하게 만들어라.
    - 정보를 제한해 결합도를 낮춰라
- 죽은 코드
    - 실행되지 않는 코드는 삭제해라!
- 수직 분리
    - 변수와 함수는 사용되는 위치에 가깝게 정의한다.
- 일관성 부족
    - 어떤 개념을 특정방식으로 구현했다면 유사한 개념도 같은 방식으로 구현한다.
    - 이름도 일관성있는 변수 이름을 사용한다
- 잡동사니
    - 아무도 사용하지 않는 변수, 함수, 주석 등 잡동사니
- 인위적 결합
    - 서로 무관한 개념을 인위적으로 결합하지 않는다
    - 일반적인 ENUM은 특정 클래스에 속할 이유가 없다. enum이 클래스에 속한다면 enum을 사용하는 코드가 특정 클래스를 알아야 한다.
    - 볌용 static 함수도 마찬가지로 특정 클래스에 속할 이유가 없다.
    - 함수 상수 변수를 선언할 때는 시간을 들여 올바른 위치를 고민한다
- 기능 욕심
    - 클래스 메서드는 자기 클래스의 변수와 함수에 관심을 가져야지 다른 클래스의 변수와 함수에 관심을 가져서는 안된다.
    - 메스드가 다른 객체의 참조자와 변경자를 사용해 그 객체내용을 조작한다면 메서드가 그 객체 클래스의 범위를 욕심내는 탓이다.
- 선택자 인수
    - 함수 호출 끝에 달리는 false 인수만큼 밉살스러운 코드도 없다
    - 선택자 인수는 목적을 기억하기 어려울 뿐 아니라, 각 선택자 인수가 여러 함수를 하나로 조합한다.
    - 인수를 넘겨 동작을 선택하는 대신 새로운 함수를 만드는 편이 좋다.
- 모호한 의도
    - 코드를 짤 때 시간을 들여 의도를 분명히 밝힌다.
- 잘못 지운 책임
    - 개발자가 내리는 중요한 결정중 하나는 코드를 배치하는 위치
    - 코드는 독자가 자연스럽게 기대할 위치에 배치
- 부적절한 static 함수
    - 인스턴스 함수로 가능하면 인스턴스 함수가 더 좋다. 조금이라도 의심스러우면 인스턴스 함수로 정의한다.
    - static으로 정의해야하면 재정의할 가능성은 없는치 살핀다.
- 서술적 변수
    - 프로그램 가독성을 높이는 가장 좋은 방법은 계산을 여러 단계로 나누고 중간 값으로 서술적인 변수 이름을 사용하는 방법
    - 서술적인 변수 이름은 많이 써도 괜찮다. 일반적으로는 많을 수록 더 좋다
- 이름과 기능이 일치하는 함수
    - 이름만으로 분명하지 않기에 구현을 살피거나 문서를 봐야한다면 좋은 이름이 아니다.
    - 더 좋은 이름을 고치도록 해야한다!
- 알고리즘을 이해하라
    - 구현이 끝났다고 선언하기 전에 함수가 돌아가는 방식을 확실히 이해하는지 확인하라
    - 테스트 케이스를 모두 통과한다는 사실로는 부족하다.
    - 알고리즘이 올바르다고 사실을 확인하고 이해하려면 기능이 뻔히 보일 ㅈㅇ도로 함수를 깔끔하고 명확하게 재구성하는 방법이 최고당
- 논리적 의존성은 물리적으로 드러내라
    - 한 모듈이 다른 모듈에 의존한다면 물리적인 의존도도 있어야 한다.
- If-else, switch-case 문보다 다형성을 사용하라
    - 그렇게 해라!
- 표준 표기법을 따르라
    - 팀은 업계 표준에 기반한 구현 표준을 따라야 한다.
        - 인스턴스 변수, 이름 선언 위치, 이름 정하는 방법..
    - 팀이 정한 표준은 팀원들 모두가 따라야 한다. 모두가 동의한 위치에 넣는다는 사실이 중요한다.
- 매직숫자는 명명된 상수로 교체하라
    - 일반적으로 코드에서 숫자를 사용하지 말라
    - 의미가 분명하지 않은 토큰 모두!
- 정확하라
    - 갱신할 가능성이 희박하다고 트랜잭션 관리를 건너뛰는 행동은 게으름이다..
    - 코드에서 뭔가를 결정할때는 정확히 결정한다.
    - 결정을 내리를 이유와 예외를 처리할 방법을 분명히 알아야 한다.
- 관례보다는 구조를 사용하라
    - 명명관례도 좋지만 구조 자체로 강제하면 더 좋다.
- 조건을 캡슐화하라
    - if (timer.hasExpired() && !timer.isRecurrent()) 보다 if (shouldBeDeleated(timer)) 가 좋다
- 부정조건은 피하라
    - 가능하면 긍적조건으로 표현한라
- 함수는 한가지만 해야한다
    - 한가지만 수행하는 좀 더 작은 함수 여럽으로 나눠야 마땅하다.
- 숨겨진 시간적인 결합
    - 때로는 시간적인 결합이 필요한다. 이러한 결합을 숨겨서는 안된다.
    - 이 때 함수 인수를 적절히 배치해 함수가 호출되는 순서를 명백히 드러낸다
- 일관성을 유지하라
    - 코드 구조를 잡을 때 이유를 고민하라
    - 그리고 그 이유를 코드 구조로 명백히 ㅠㅠㅛ현하라.
- 경계조건을 캡슐화하라
    - 경계 조건은 빼먹거나 놓치기 십상이다 경계 조건은 한 곳에서 별도로 관리한다.
- 함수는 추상화 수준을 한 단계만 내려가야 한다.
    - 함수 내 모든 문장은 추상화 수준이 동일해야 한다.
    - 그리고 추상화 수준은 함수 이름이 의미하는 작업 보다  한 단게만 낮아야 한다.
    - 가장 어려운 항목..이다. 인간은 추상화 수준을 뒤섞는 능력이 너무 뛰어나기 때문에 ㅠㅠ
- 설정 정보는 최상위 단계에 둔다.
- 추이적 탐색을 피하라
    - 일반적으로 한 모듈은 주변 모듈을 모를 수록 좋다.
    - A 가 B를 사용하고  B가 C를 사용해도 A가 C를 알 필요는 없다. → 디미터의 법칙
    - 무엇이라 부르든 자신이 직접 사용하는 모듈만 알아야 한다.

### 자바

- 긴 import 보다 * 와일드 카드를 사용하라
- 상수는 상속하지 않는다.
- Enum을 사용하라

### 이름

- 서술적인 이름을 사용하라
    - 시간을 들여 현명한 이름을 선택하고 유효한 상태로 유지한다.
    - 대충 정하기에 이름은 너무 중요하다 ㅠㅠ
- 적절한 추상화 수준에서 이름을 선택하라
    - 구현을 드러내는 이름은 피하라
- 가능하다면 표준명명법을 사용하라
    - ex) 디자인패턴, 알고리즘 이름
- 긴 범위는 긴 이름을 사용하라
    - 이름 길이는 범위 길이에 비례해야한다.
- 인코딩을 피하라
    - 이름에 유형정보나 범위 정보를 넣어서는 안된다
- 이름으로 부수효과를 설명하라

### 테스트

- 불충분한 테스트
    - 불행히도 많은 개발자들이 이정도면 충분하지 않을까?를 척도로 사용한다.
    - 테스트 케이스는 잠재적으로 꺠질만한 부분을 모두 테스트 해야한다.
    - 테스트 케이스가 확인하지 않는 조건이나 검증하지 않는 계산이 있다면 이는 불완전 하다
- 커버리지 도구를 활용하라
- 사소한 테스트를 건너뛰지 마라
- @Ignore한 테스트는 모호함이다.
- 경계 조건을 테스트 하라
- 버그 주변은 철저히 테스트하라
    - 버그는 서로 모이는 경향이 있다.
    - 버그 함수 근처는 철저히 테스트한다.
- 실패 패턴을 살펴라
- 테스트는 빨라야한다.