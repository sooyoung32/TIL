# http header

### header 개요
- 필드 이름 : 필드 값
- http  전송에 필요한 모든 부가정보
- 바디 내용, 바디 크키, 압축, 인증, 요청 클라이언스
- 필요시 임의 추가 가능
- 분류-RFC-2616 (과거)
    - 일반 헤더
    - 요청 헤더
    - 응답 헤더
    - 엔티티 헤더
        - content type
        - 엔티티 본문의 데이터를 해석할 수 있는 정보 제공
        - 데이터 유형, 데이터 길이, 압축 정보
- RFC 7230~35 (최신)
    - 엔티티 → 표현 representation
    - 메시지 본문을 통해 표현 데이터 전달
    - 메시지 본문 = 페이로드
    - 표현은 요청이나응답에서 전달할 실제 데이터
    - 표현 헤더는 표현 데이터를 해석할 수 있는 정보 제공
        - 데이터유형, 데이터 길이, 압축 정보
    - 표현 헤더는 표현 메터데이터와 메이로드 메시지를 구분해야하지만

### 표현
- content type : 표현 데이터의 형식 (json, html)
    - 미디어 타입, 문자 인코딩
    - application/json

- content encoding : 표현 데이터의 압축 방식
    - 표현 데이터를 압축하기위해 사용
    - 데이터를 전달하는 곳에서 압축 후 인코딩 헤더 추가
    - 데이터를 읽는 쪽에서 인코딩 헤더 정보 읽어서 압축 해제
    - gzip
    - identity : 압축 안한다
- content language : 표현 데이터의 자연 언어
    - ko, en, en-US
- content length : 표현 데이터의 길이
    - 바이트 단위
    - transfer encoding을 사용하면 length는 사용하면 안됨
- 표현헤더는 전송 응답 둘다 사용

 ### 협상 (content negotiation)

* 클라이언트가 선호하는 표현 요청
    - accept: 클라이언트가 선호하는 미디어 타입 전달
    - accept charset : 클라이언트가 선호하는 문자 인코딩
    - accept encoding: 클라이언트가 선호하는 압축 인코딩
    - accept language: 클라이언트가 선호하는 자연 언어

- 협상헤더는 요청에만 사용
  * 협상과 우선순위 1
    - quality value 갑 사용
    - 0-1 클수록 높은 우선순위, 생략하면 1

  * 협상과 우선순위 2
    - 구체적인 것이 우선한다
  * 협상과 우선순위 3
    - 구체적인 것을 기준으로 미디어타입을 맞춘다

  ### 전송 방식
    - 단순 전송 : content length
    - 압축 전송 : content encoding
        - gzip
    - 분할 전송 : transfer encoding
        - chunked 단위로 전송
        - content length를 넣으면 안됨
            - chunked마다 길이가 있고 어차피 계산할 수 없음
    - 범위 전송 : content range
        - 범위를 지정해서 전송

  ### 일반 정보

    - from 유저 에이전트 이메일 정보
        - 일반적으로 잘 사요 ㅇ안함
        - 검색엔진에서 주로 사용
        - 요청에서 사용
    - referer : 이전 웹 페이지 주소
        - referer를 사용해서 유입 경로 분석 가능
        - 요청에서 사용
        - referrer 오타..
    - user agent : 유저 에이전트 어플리케이션 정보
        - 클라이언트 어플리케이션 정보
    - server : 요청 처리하는 origin 서버의 소프트 웨어 정보
        - server : nginx
        - 응답에서 사용
    - date : 메시지가 발생한 날짜와 시간
        - 응답

### 특별한 정보
##### host : 요청한 호스트 정보 (도메인)
- 필수 값
- 요청에서 사용
- 하나의 서버가 여러 도메인을 처리해야할때
- 하나의 ip 주소에 여러 도메인이 있을때

##### location : 페이지 리다이렉션
- 웹 브라우저는 3xx 응답 결과에 location이 있으면 그 위치로 이동
- 201 의 경우 created 된 리소스 uri

#### allow : 허용 가능한 http 메서드
- 405에서 응답에 포함해야함
- 잘 구현되어 있지 않음

#### retry after
- 유저 에이전트가 다음 요청을 하기 까지 기다려야 하는 시간
- 503의 경우

#### 인증
- authorization: 클라이언트 인증 정보 서버에 전달
    - authorization: Basic xxxxxxxxxxxxxx
    -
- www-authenticate : 리소스 접근시 필요한 인증 방법 정의
    - 401 응답과 함께사용

#### 쿠키
- set-cookie 서버에서 클라이언트로 쿠키 전달
- cookie: 클라이언트가 서버에서 받은 쿠키를 저장하고 전달한다
- http 무상태 프로토콜!
    - 대안
        - 모든 요청에 사용자 정보 추가 ?
        - 쿠키
- 서버 → 클라이언트 쿠기 전달
- 클라이언트 웹브라우저 내부에 쿠키 저장소에 저장
- 쿠키가 있는 경우 유저정보를 서버에 전달
- 모든 요청에 쿠기 정보 자동 포함
- 사용처
    - 로그인 세션 관리
    - 광고 정보 트래킹
- 쿠기 정보는 항상 서버 전송됨
    - 네트워크 트래킹 추가 유발
    - 최소한의 정보만 사용 (세선 id, 인증 토큰)
    - 서버에 전송하지 않고, 웹브라우저 내부에 데이터를 저장하고 싶으면 웹 스토리지 localstorage, sessionstorage) 참고
- 주의
    - 보안에 민감한 데이터는 저장하면 안됨
- 생명주기
    - expries, max-age
        - 만료일 되면 쿠키 삭제,
    - 세션 쿠키 : 만료날짜 생략하면 브라우저 다을 떄 종료
    - 영속 쿠키 :
- 도메인 지정
    - domain
    - 명시한 문서 기준 도메인 + 서브 도메인 포함
    - 생략 : 현제 문서 기준 도메인만 적용
- 경로
    - path
    - 이 경로를 포함한 하위 경로 페이지만 쿠키 접근
    - 일반적으로 path /루트로 지정
- 보안
    - secure
        - https 인 경우에만 전송
    - httpOnly
        - xss 공격 방지
    - sameSite
        - xsrf 공격 방지
        - 요청 도메인과 쿠키에 설정된 도메인이 같은 경우에만 쿠키 전송

### 캐시 기본 동작
* 캐시 없을때
    - 캐시 없을 때는 동일한 용량의 데이터를 전송해서 받아서 적용해야함
    - 인터넷 네트워크는 매우 느리고 비싸다
    - 브라우저 로딩 속도가 느리다
    - 느린 사용자 경험

* 캐시 적용
    - cache-control : max-age=60
    - 브라우저 캐시 저장소에 응답 결과 저장
    - 비싼 네트워크 사용량을 줄일 수 있다
    - 브라우저 로딩 속도가 빠름
    - 캐시 시간 초과
        - 캐시 시간 초과하면 다시 조회하고 캐시를 갱신
        - 이때 네트워크 다운로드가 발생

* 검증 헤더와 조건부 요청
    - 캐시 유효 시간 초과시 서버에서 다시 요청한 경우
        - 서버에서 기존 데이터 변경함
        - 서버에서 기존 데이터 변경하지 않음
            - 데이터를 전송하는 대신 저장해두었던 캐시 재사용
            - 검증 헤더
                - (응답) last-modified: 2021년 05월 13일 11:00
                - (요청) if-modified-since: 2021년 05월 13일 11:00
                - 두 헤더가 날짜가 동일하면
                - 304 Not Modified
                    - body가 존재하지 않음
                - 304 응답 후 브라우저 캐시 업데이트
    - 캐시 유효기간 초과해도 서버의 데이터가 갱신되지 않으면 304 + 헤더값만 응답
    - 클라이언트는 서버가 보낸 응답 헤더의 정보로 요청 갱신
    - 클라이언트 저장소에 있는 캐시 재사용 가능

* 검증 헤더
    - 캐시 데이터와 서버 데이터가 같은지 검증하는 데이터
    - last modified, ETag

* 조건부 요청 헤더
    - 검증 헤더 조건에 따른 분기
    - if-Modified-Since : 이후에 데이터가 수정되었어요?
        - 304 Mot Modified + 헤더 정보만
    
- 데이터 변경
    - 200 OK + 바디
- 단점
    - 1초 미만 단위로 캐시 조정 불가
    - 날짜 기반의 로직 사용
    - 데이터를 수정해서 날짜가 다르지만, 같은 데이터를 수정해서 데이터 결과가 똑같은 경우
    - 서버에서 별도의 캐시 로직을 관리하고 싶은 경우
    - → ETag
- ETag (Entity Tag)
    - 캐시용 데이터에 임의의 고유한 버전 이름을 달아둠
    - 데이터가 변경되면 이름을 바꿔서 변경
    - ETag가 같으면 유지, 다르면 다시 받기
    - 요청 if-None-Match  : "aaaa"
        - 변하지 않으면 304
        - 변했으면 200
    - **캐시제어로직을 서버에서 관리**

* 캐시 헤더
    - cache-control
        - max-age : 캐시 유효 시간
        - no-cache : 데이터는 캐시해도 되지만, 항상 origin 서버에서 검증하고 사용
        - no-staore : 데이터에 민감한 정보가 있음으로 저장하면 안됨
    - Pragma (캐시제어 하위호환)
    - Expires (캐시 만료일 지정, 하위호환)

* 조건부 헤더
    - ETag
    - Last-Modified

* 프록시 캐시
    - 원 서버 직접 접근
    - 프록시 캐시 서버
        - 한국 → 미국  0.5ms
        - 한국 (private 캐시) → 프록시 캐시 서버(한국) (public 캐시) → 미국 0.1 ms
    - Cache Control
        - Cache Control : public
        - Cache Control : private
            - 민감한 정보
        - Cache Control : s-maxage
        - Age: 60

* 캐시 무효화
    - 아래 값을 다 넣어야함!!
    - Cache-Control: no-cache, no-store, must-revalidate
    - Pragma: no-cache
        - HTTP 1.0 하위 호환
        - no-cache vs must revalidate

- 캐시 만료후 최초 조회시 원 서버에 검증
- 원서버 접근 실패시
    - 오류 보다 오래된 데이터를 보여주자 (no-cache)
    - 504 예외 응답  (must-revalidate)