## ECMAScript 2016 / ES6

### ECMAScript란?
* ECMA스크립트(ECMAScript)는 자바스크립트 언어의 표준을 정의한 규격이다. 자바스크립트 엔진, 렌더링 엔진 등 브라우저 소프트웨어에 포함된 구성 요소들이 이 규격에 따라 웹 문서와 웹 애플리케이션에 들어간 자바스크립트 코드를 처리한다.
* ECMAScript는 브라우저에 상관없이 Javascript의 일반적인 측면을 다루고 HTML, CSS, 또는 DOM (Document Object Model) 같은 Web API들은 ECMAScript 표준의 대상이 아닙니다.

### ECMAScript2015? ES6?
ECMA에서 ECMAScript 표준 갱신 주기를 1년 단위로 하고 후속 표준 명칭 뒤에 버전 대신 년도를 쓰기로 했다고 합니다. 그래서 지난 2015년 ECMA에서 자바스크립트의 새로운 표준을 만들었고, 이는 ECMAScripte 스펙 6번째 에디션이란 뜻입니다.

ES6는 자바스크립트에 있었던 업그레이드 중 가장 중 가장 큰 혁신이라고 할만큼 많은 기능이 추가 되었다.
* **let, conts 키워드, 해체할당**
* 형을 정의하는 Class 
* 간결한 익명함수 Arrow Funtion
* 효과적인 비동기 프로그래밍 Promise
* Symbol 타입.
* Iterator, Generator
* 모듈


### ES6 기초 문법

##### let
let은 **블록 스코프 변수**를 선언하는 키둬드로, 선언과 동시에 값을 할당할수 있다.

* 기존 자바스크립트는 블록 스코프에 대한 개념이 없어 메모리 누수가 발생할 소지가 있으며 읽기 힘들고 디버깅이 어렵다.
~~~javascript
var a = 12; //전역 접근 가능
function myFunction(){
	console.log(a);
	var b = 13; //함수 안에서 접근 가능
	if(true)  {
		var c = 14; //함수 안에서 접근 가능
		console.log(b);
	}
    console.log(c);
}
myFunction();
~~~

이를 보완하기 위해 let 키워드로 선언한 변수는 블록 스코프 변수라 하며, 함수 밖에 선언하면 전역으로 접근 가능하고, 블록 안에서 선언하면 해당 블록 에서만 접근 가능하다.
~~~javascript
let a = 12; //전역 접근 가능
function myFunction(){
	console.log(a);
	let b = 13; //함수 안에서 접근 가능
	if(true)  {
		let c = 14; //"if" 문 안에서 접근 가능
		console.log(b);
	}
    console.log(c); // reference error exception
}
myFunction();
~~~

let 키워드를 사용한 변수는 변수를 재선언 할수 없다.
~~~javascript
var a = 0;
var a = 1;
console.log(a); // a = 1

// 같은 스코프 내에서 변수를 재선언하면 type error
let a = 0;
let a = 1; // type error
~~~

##### const
const는 변하지 않는 값, 상수를 선언하는 데 사용한다. const의 스코프는 let과 같다.

~~~javascript
//이전
var const_pi = 3.14;
var r = 2;
console.log(const_pi * r *r) ;

//ES6
const const_pi = 3.14;
var r = 2;
console.log(const_pi * r *r) ;

const_pi = 11; // 읽기전용 예외

~~~

const 에 객체를 할당할시 객체 참조값이 저장됨으로 참조 값이 상수에 저장된다. 따라서 객체는 가변상태다.

~~~javascript
const a = {
   "name" : "민호"
};
console.log(a.name); 
a.name = "수지";
console.log(a.name);
a = {}; //읽기 전용 예외 발생
~~~

##### 파라미터 기본값
자바스크립트는 함수가 파라미터 값을 받지 못할때 기본값 (default 값)을 지정하기가 불편했는데 ES6 에서는 파라미터에 기본값을 설정할수 있다.

~~~javascript
//이전
function a(x,y,z) {
	x = x ==== undefined ? 1 : x;
    y = y ==== undefined ? 2 : y;
    z = z ==== undefined ? 3 : z;
    console.log(x,y,z);
}
//es6
function a(x =1,y=2,z=3) {
	console.log(x,y,z);
}
~~~

##### 펼침 연산자 Spread Operator
이터러블 객체를 개별 값으로 나누는 펼침 연산자가 생기고 ... 표현한다.
펼침연산자는 함수 인자나, 배열 등이 나오는 곳이며 어디라도 쓸수있고, 보통 이터러블 객체를 여러 함수 인자로 펼치는데 자주 쓴다.

~~~javascript
function a(a,b) {
	return a+b;
}
var data = [1,4];
var result = a.apply(null, data); // 배열을 하나하나 꺼내 개별적 함주 인자로 만들어 호출
console.log(result); // 5

//es6
let data = [1,4];
let result = a(...data); // ...data를 먼저 1,4로 치환해 a를 호출 하는 방식
console.log(result); //5

// 다른 예

let arr1 = [2,3,4];
let arr2 = [1, ...arr1, 5,6,7];
console.log(arr2) // 1,2,3,4,5,6,7

let arr1 = [1];
let arr2 = [2];
let arr3 = [...arr1, ...arr2, ...[3,4]];
let arr4 = [5];

function a (a,b,c,d,e) {
	return a+b+c+d+e;
}
let result = a (...arr3, ...arr4);
console.log(result); // 15;

~~~

##### 해체할당 Destructured assignment 
해체할당은 이터러블이나 객체의 값/프로퍼티를 각각 배열이나 객체의 생성자 리터럴과 비슷한 구문으로 변수에 할당하는 표현식이다.

* 배열 해체 할당
배열 해체 할당은 이터러블 객체에서 값을 추출하여 변수에 할당한다.

~~~javascript
//이전
var arr = [1,2,3];
var a = arr[0];
var b = arr[1];
var c = arr[2];

//es6
let a,b,c;
[a,b,c] = arr;

let [a,b,c] = [1,2,3];

let [a,,b]= [1,2,3];
console.log(a);//1
console.log(b);//3

//... 나머지 연산자 사용
let [a, ...b] = [1,2,3,4,5,6,7];
console.log(a); //1
console.log(Array.isArray(b));// true
console.log(b);// 2,3,4,5,6,7

let [a,b,c=3] = [1,2];
console.log(c);//3

let [a,b, [c,d]] = [1,2, [3,4]];

~~~


* 객체 해체 할당
객체 해체할당은 객체 프로퍼티 값을 추출해서 변수에 할당한다.

~~~javascript
//이전
var obj = {"name" : "수영", "age": 27};
var name = obj.name;
var age = obj.age;


//es6
let name, age;
({name, age} = obj) //객체의 프로퍼티 명과 변수명이 같아야함!

//중첩 객체인경우
var {name, otherObj:{age}} = {name : "수영", otherObj: {age:27}}; 
console.log (name, age); //수영, 27

~~~

##### 화살표 함수 Arrow function 
화살표 함수는 보다 간결해진 익명함수고 => 연산자로 생성한다.

~~~javascript
//이전
var circleArea = function(pi, r) {
	var area = pi * r * r;
    return area;
}

//es6
 let circleArea = (pi, r) => {
    let area = pi * r * r;
    return area;
}

//한문장이라면
let circleArea = (pi, r) => pi * r * r;

~~~

화살표 함수에서 this 값은 해당 스코프(화살표 함수를 정희한 지점을 둘러싼 저역/함수 스코프)의 this와 같다. 

~~~javascript
//이전
var obj = {
	f1 : function() {
    	console.log(this);
        var f2 = function() {console.log(this);}
        f2();
        setTimeout(f2, 1000);
    }
}
obj.f1();

// Object, Window, Window 
// f1은 object 의 프로퍼티 이므로 f1 함수의 this는 object 이다. f2는 window 개체의 프로퍼티 여서 window 


//es6
 var object = {
    f1: () => {
      console.log(this);
       var f2 = () => { console.log(this); }
       f2();
       setTimeout(f2, 1000);
    }
}

// window, window, window 
// f1의 스코프가 전역이므로 f1 의 this는 전역 스코프의 this다. 마찬ㄱ가지로 f2는 f1 스코프 안에 있어 f2의 this는 f1의 this를 가리킨다.
~~~

### ES6 를 사용하려면
ES6를 호환하지 않는 엔진에서 ES6 코드를 실행시키려면 ES6를 ES5 소스코드로 변환시켜주는 트렌스파일러 필요합니다.

즉 코드는 ES6로 작성하고 트랜스파일러를 이용해 코드를 ES5로 변환해 모든 자바스크립트 엔진에서 사용할수 있게 하는것!

트렌스파일러의 종류는 트레이서, 바벨, 카자 등 여러가지가 있지만 새로운 문법을 가장 많이 지원하고 인기있는 것이 [bebel](https://babeljs.io/)이라고합니다!

저는 간단히 예제코드를 실행시켜 보기 위해 구글 트레이서 cdn 을 아래와 같이 이용했지만 제대로 사용하고 싶다면 babel을 권장합니다.
~~~html
<script src="https://google.github.io/traceur-compiler/bin/traceur.js"></script>
      <script src="https://google.github.io/traceur-compiler/bin/BrowserSystem.js"></script>
      <script src="https://google.github.io/traceur-compiler/src/bootstrap.js"></script>
~~~

### ECMAScript2016 ES7?
표준 주기를 1년으로 정한 후 첫 정식 릴리즈. 지난 6월 ECMAScirpt 2016을 공개! 했고 ECMAScript2015와 크게 다르진 않지만 몇가지 추가된 기능이 있다고 합니다.
* 거듭제곱 연산자 "**" a=b**5
* 배열 안에 특정 요소 찾는 includes 메소드 추가

크롬 52 버전에서 지원한다고 합니다!
