## 트랜젝션 범위의 영속성 컨텍스트

- 스프링 컨테이너는 트랜잭션 범위의 영속성 컨텍스트 전략이 기본
- 트랜잭션 범위와 영속성 컨텍스트의 생존 범위가 같다.
- 트랜잭션이 같으면 같은 영속성 컨텍스트를 사용한다. → 트랜젝션이 다르면 다른 영속성 컨택스트 사용
    - 여러 스레드에서 동시에 요청이 와서 같은 엔티티 매니저를 사용해도, 트랜잭션에 따라 접근하는 영속성 컨텍스트가 다르다.  → 스프링 컨테이너는 스레드마다 각각 다른 트랜잭션을 할당한다.  → 따라서 같은 엔티티 매니저를 호출해도 접근하는 영속성 컨텍스트가 다르므로 멀티 스레드 상황에 안전하다.

## 준 영속 상태와 지연로딩

- 조회한 엔티티가 서비스와 레포지토리 계층에서는 영속성 컨텍스트에 관리되면서 영속 상태를 유지하지만, 컨트롤러나 뷰 같은 프레젠테이션 계층에선 준영속 상태가 된다.

### 준영속 상태와 지연로딩

- 프레젠테이션 계층에서 데이터를 불러올때 준영속 상태인 경우 LazyInitializationException 이 발생한다.
- 해결 방법
    - 뷰가 필요한 엔티티를 미리 로딩
        - 글로벌 페치 전략 수정 → 즉시로딩으로 변경
            - 이건 실무에서 절대 안됨.
            - 사용하지 않는 엔티티도 로딩되고
            - N+1 발생
        - JPQL 페치 조인 사용
            - 이게 현실적인 대안이지만 무분별하게 사용하면 화면에 맞춘 리포지토리 메소드가 증가할 수 있음. → 즉 프리젠테이션 계층이 데이터 접근 계층을 침범하는 것..
            - 뷰와 리포지토리간의 논리적인 의존관계 발생
        - 강제 초기화
            - 영속성컨텍스트가 살아있을때 프리젠테이션 영역에서 필요한 데이터를 강제로 초기화 함.
            - 프록시를 초기화하는 역할을 서비스 계층이 담당하면 뷰가 필요한 엔티티에 따라 서비스 계층 로직을 변경해야 함.
            - 은근 프리젠테이션 계층이 서비스 계층으로 침범...
            - 서비스 계층은 비즈니스 로직을 담당해야지 프리젠테이션 계층을 위한 일까지하는건 좋지 않음..
            - 이를 해결하기 위해 FACADE 계층을 추가
                - Controller → Facade → Service or Repository
                - 역할과 특징
                    - 뷰 계층과 도메인 모델 계층간 논리적 의존성 분리
                    - 뷰 계층에서 필요한 프록시 객체 초기화
                    - 서비스 계층 호출해 비즈니스 로직 수행
                    - 리포지토리 직접 호출해 뷰가 요구하는 엔티티 찾음
                - 단점은 더 많은 코드를 작성해야함. 더 많은 유지보수가 필요함..

    - OSIV를 사용해 엔티티를 항상 영속 상태로 유지
        - Open Session in View 는 영속성 컨텍스트를 뷰까지 열어둔다는 뜻. 즉 뷰에서도 지연로딩 가능
        - 과거에는 요청당 트랜젝션으로 클라이언트 요청이 들어오자마자 서블릿 필터나 스프링 인터셉터에 트랜잭션을 시작하고 요청이 끝날때 트랜잭션도 끝남.  이는 뷰에서 데이터 변경이 할 수 있는 문제점.. 😱
        - 스프링에서 제공하는 OSIV 라이브러리 사용
            - 비즈니스 계층에서 트랜잭션을 사용하는 OSIV . OSIV이긴 하지만 트랜잭션은 비즈니스 계층에서만 사용.
            1. 클라이언트 요청 → **영속성 컨텍스트 생성. 이때 트랜젝션은 시작하지 않음.**
            2. 서비스 계층에서 @Transactional로 트랜젝션을 시작할때 1번에서 생성해둔 영속성 컨텍스트를 찾아와서 트랜젝션 시작
            3. 서비스 계층이 끝나면 트랜젝션은 커밋하고 영속성 컨텍스를 플러시. 이때 **트랜젝션은 끝나지만 영속성 컨텍스트는 종료하지 않음**
            4. 컨트롤러와 뷰까지 영속성 컨텍스트가 유지되므로 조회한 엔티티는 영속상태 유지 
            5. 서블릿 필터나 스프링 인터셉터로 요청이 돌아오면 영속성 컨텍스트를 종료한다. 이때 **플러시를 호출하지 않고 바로 종료.**
        - 트랜잭션 없이 읽기
            - 영속성 컨텍스트는 트랜잭션 범위 안에서 엔티티를 조회하고 수정할 수 있다.
            - 영속성 컨텍스트는 트랜잭션 범위 밖에서 엔티티를 조회만 할 수 있다. 이를 트랜잭션 없이 읽기라 한다.
            - 스프링의 OSIV를 사용하면 뷰계층에서는 트랜잭션 없이 읽기를 사용해 지연로딩기능을 사용 할 수 있다.
        - 영속성 컨텍스트를 프리젠테이션 계층까지 유지
        - 프리젠테이션 계층에는 트랜젝션 없어서 수정은 불가능하나,  트랜젝션 읽기를 사용해 지연로딩 가능
        - 단점
            - OSIV를 사용하면 같은 영속성 컨텍스트를 여러 트랜잭션이 공유할 수 있다. → 롤백시 진짜 주의
            - 프리젠테이션 계층에서 엔티티 수정하고 나서 비즈니스 로직 수행하면 엔티티가 수정될 수 있다.
            - 프리젠테이션 계층에서 지연로딩에 의한 SQL이 실행되기때문에 성능튜닝시 확인해야할 부분이 많다 .