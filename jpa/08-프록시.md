# 프록시

Member 조회시 Team도 함께 조회해야 할까? 사용하지 않는데도?

- em.find)() : 엔티티 조회
- em.getReference() :  db 조회를 미루는 가짜(프록시)  엔티티 객체 조회
    - 레퍼런스 할때는 쿼리 수행이 안되고, 값이 실제 사용되는 시점에 쿼리가 조회됨.
    - hibernate가 강제로 만든 프록시 객체가 리턴됨

### 특징

- 실제 클래스를 상속 받아 만들어짐
- 겉모양이 같음
- 사용하는 입장에서 진짜 객체인지 프록시 객체인지 구분하지 않고 사용하면 됨.
- 프록시 객체는 실제 객체의 참조 (target)을 보관
- 프록시 객체를 호출하면 프록시 객체는 실제 객체의 메소드 호출

### 중요

- 프록시 객체는 처음 사용할 때 한번만 초기화
- 초기화할때 프록시 객체가 엔티티로 바뀌는게 아님.
- 초기화 되면 프록시 객체를 통해 엔티티에 접근가능
- 프록시 객체는 원본 엔티티를 상속받음 →  타입체크 주의.
    - == 비교 안됨, 대신 instance of 비교
- 영속성 컨텍스트에 찾는 엔티티가 있으면 em.getReference() 호출하고 프록시가 아닌 실제 엔티티 반환
    - 1차캐시에 이미 있기 때문에 있는 엔티티를 반환함  성능상 이점
    - 동등성 비교, repeatable read 보장 → em.find() 해도 프록시가 나올 수 있음.
    - 따라서 프록시이든 아니든 개발에 이슈가 없도록 해야함.
- 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일때 프록시를 초기화 하면 문제 발생. → 하이버네이트는 LazyInitializedException  발생
- member.getNmae() → 하면서 프록시 강제 초기화가 되는 것임

## 지연로딩 즉시로딩

**가급적 지연로딩만 사용(실무에서)**
즉시로딩을 적용하면 예상치 못한 sql 발생
- 관계가 복잡할 경우 join이 다 걸리면서.....무서운 쿼리가 실행됨
즉시로딩은 jpql에서 n+1 문제
- jpql은 실제 쿼리와 유사하기 때문에... jpql 사용시 member 따로 team 따로 조회됨.
@many to one @ one to one은 즉시로딩이 기본 → lazy로 바꿔서 사용해야함
실무에서는 일단 Lazy만 사용하고

1. jpql 에서는 fetch join을 사용  
2. Entity Graph 를 사용

### 지연로딩

fetch = FetchTYpe.LAZY → 하면 프록시 객체를 리턴함 
실제 사용하는 시점에 초기화하면서 select 쿼리가 실행됨. 

### 즉시로딩

fetch = FetchType.EAGER → 엔티티가 리턴됨. 
쿼리 조인해서 한번에 가져옴!

## 영속성 전이 cascade

특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶을때 
부모 엔티티 저장시 자식도 같이 저장하는 경우 
연관관계 매핑하는것과노상관

실무에서도 잘 사용됨
소유자가 하나일때만 사용가능 → 다른 엔티티에서 부도 엔티티가 아닌 자식 엔티티를 사용한다면 사용하면 안됨
패런트와 차일드의 생명주기가 유사할때, 패런트가 차일드만 소유할때 사용

## 고아 객체

고아객체 제거 : 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제 (delete 쿼리가 발생) 
orphanremonal = true
참조하는 곳이 하나일 때 사용해야함!!
특정 엔티티가 개인 소유할때 사용해야함!!
부모가 삭제 되면 자식도 다 삭제됨.
### 영속성전이와 고아 객체를 같이 사용하는 경우
부모 엔티티를 통해 자식 엔티티의 생명주기를 관리할 수 있음
도메인 주도 설계의 aggregate root개념을 구현할 때 유용